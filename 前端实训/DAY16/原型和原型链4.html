<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script>
			// 声明了一个构造函数，加入了 实例成员 和 静态成员
			function Star(uname, age) {
				this.uname = uname;
				this.age = age;
			}
			// 每添加一个静态成员，都需要去手动往原型链中添加
			// 这种方法不会修改原本的原型的内容,所以也就不会影响到
			// constructor属性指向构造函数
			// Star.prototype.sing = function() {
			// 	console.log("我会唱歌");
			// };
			// Star.prototype.movie = function() {
			// 	console.log("我会拍电影");
			// };

			// 既然原型是一个对象，我们是否可以使用一个新的对象替换它
			// 事实上,我们可以使用其他对象替换原本的原型对象
			// 这样的写法会有一个小小的问题
			// 会将原本的原型中的内容覆盖掉,所以constructor构造函数的指向受到了影响
			Star.prototype = {
				constructor: Star,
				sing: function() {
					console.log("我会唱歌");
				},
				movie: function() {
					console.log("我会拍电影");
				}
			}


			var ldh = new Star('刘德华', 20);
			ldh.sing();
			ldh.movie();


			// 原型对象本身也是一个对象类型,只要是对象类型都会有原型
			// 也可以通过原型对象的原型访问,一直访问到object对象为止
			// object 是 所有的js对象父类
			ldh.__proto__.__proto__.__proto__
			// 当查找一个值的时候,会先在当前的对象中找这个值,如果没有,则在上一级的原型中查找,如果还没有,则上上级原型,直到找到null,报错
			// 这也是为什么,我们说,原型和原型链的意义,是提供一个查找值的方向,给对象
		</script>
	</body>
</html>