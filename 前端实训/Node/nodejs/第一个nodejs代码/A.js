// 导出方法1
// import B from "./B.js";
// 导出方法2
// require('./B.js');

// 正确的写法是，我们在导入的时候，也需要使用一个变量名接收
let B = require('./B.js');
console.log("使用对象.的方式，使用函数或者变量");
console.log(B.add(10, 20));
// 当前代码中，声明一个同名的函数，完全没有问题
let add = () => { }

// 这样的模块化的方式，避免了变量名污染的问题
// console.log("外部的num", num);

// 这个值不能够直接使用，因为如果导出了就能够使用
// 还是无法避免，变量名污染的问题
// console.log("得到的结果:", add(10, 20));

// 因为b.js也是我们完成的代码，所以我们知道不能再使用add了
// 问题是，别人写的插件我不知道，他到底导入了什么对象，使用了什么样的值
// let add = ()=>{}
