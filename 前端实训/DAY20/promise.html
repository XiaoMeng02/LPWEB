<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script>
			// 回调函数
			// 异步操作，也称之为回调函数，承诺会在未来的某一个
			// 条件下被触发的函数，称之为回调函数
			// let callback = () => {
			// 	console.log("0");
			// }

			// 异步和同步
			// 异步代码，会在条件成立的时候再触发
			// 这种不知道什么时候会被执行的代码，称之为异步代码
			// setTimeout(callback, 0)



			console.log("同步代码1");
			// 学代码先学结构，然后理解含义
			// 这个就是Promise对象的结构
			// 网络请求方面的执行时间，是不确定的
			let p = new Promise(function(resolve, reject) {
				// 这个容器本身不是异步的
				console.log("同步代码2");
				// 容器里面通常要包含一个异步代码
				// 使用一个定时器，模拟网络请求的延时
				setTimeout(function() {
					//获取一个随机数的值
					let v = Math.random();

					// 通过判断这个值，模拟前后端交互的操作
					// 由于网络问题，或者线路切换之类的问题，前后端交互
					// 不总是成功的，使用随机值模拟成功或者失败
					if (v > 0.5) {
						// 通过传入的函数，来执行调用
						// 成功情况下执行resolve的调用
						resolve("网络请求成功");
					} else {
						// 失败情况下执行reject的调用
						reject("网络请求失败");
					}
					// 通过这样的方式，这个异步代码同时
					// 兼顾处理成功和处理失败的情况
				}, 3000)
			})
			console.log("同步代码3");

			// 如果是容器内的代码都是异步代码
			// 执行结果应该是：同步代码1，同步代码3，同步代码2
			// 由于容器内不是异步代码，所以执行顺序是
			// 同步代码1，同步代码2，同步代码3

			// 容器的使用
			// 可以理解为一种异步用的分支语句
			// 我们根据异步代码的执行结果，来决定后面的代码如何执行
			p.then(function(rlt) {
				// 网络请求成功后的代码
				console.log(rlt);
			}).catch(function(rlt) {
				// 网络请求失败后的情况
				console.log(rlt);
			}).finally(function() {
				// 无论执行成功还是失败，都会执行的代码
			});

			// promise的容器接受两个调用
			// then方法，接收resolve方法作为执行成功后的调用
			// catch方法，接收reject方法作为执行失败后的调用
		</script>
	</body>
</html>