<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<button>新增一个账户</button>
		<script>
			// 绑定的按钮
			let btn = document.querySelector("button");
			let rls = "";

			btn.addEventListener("click", () => {
				// 1. 创建连接对象
				let xhr = new XMLHttpRequest();

				// 2. 设置连接信息
				xhr.open("post", "http://localhost:3000/users");

				// post类型提交数据的时候，需要额外的设置内容类型
				// 这是为了让服务器知道，我们发送的是什么玩意，设置的消息头
				xhr.setRequestHeader('Content-Type', 'application/json');


				// 3. 发送请求数据
				let param = {
					username: "xiaoli",
					password: "123456",
					age: 28,
					gender: "男",
					address: "北京市朝阳区",
					phone: "13800138000",
					email: "xiaoli@example.com"
				}
				// 真正的登陆注册行为需要在前端就进行验证
				// 验证数据是否合格
				// post需要将发送的数据放在send方法的参数中
				// 将json类型的对象转化为文本的方法
				xhr.send(JSON.stringify(param));
				// 4. 获取响应信息

				xhr.addEventListener("load", () => {
					// 这里获取到的值是字符串类型，无法使用
					console.log(xhr.responseText);
					// 将变成文本的数据，转化为对象使用
					rls = JSON.parse(xhr.responseText);
				});

				// 为什么数据在传输之前，都要变成文本发送？
				// 因为对象本身不止数据相关的内容，还包括原型，原型里面的方法，原型的原型等，内容，我们传输10个字符的数据，可能包含了很多很多的额外内容
				// 将JSON类型转换为对象，和将对象类型转换为JSON类型
				// 这两种方法，被称之为序列化和反序列化
				JSON.stringify({
					username: "xiaoli",
					password: "123456",
				}); //序列化
				JSON.stringify(`{
					username: "xiaoli",
					password: "123456",
				}`);//反序列化
			})
		</script>
	</body>
</html>